{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Elm-MicroScheme Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub . Directions To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter. Layout of the code ---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Eval.elm 40 10 92 src/MicroScheme/Frame.elm 25 0 64 src/MicroScheme/Parser.elm 28 11 56 src/MicroScheme/Interpreter.elm 18 14 43 src/Main.elm 22 0 41 src/MicroScheme/Environment.elm 9 0 19 src/MicroScheme/Expr.elm 4 0 13 src/MicroScheme/Init.elm 3 0 10 ---------------------------------------------------------------------------------- SUM: 149 35 338 ----------------------------------------------------------------------------------","title":"Home"},{"location":"about/#elm-microscheme","text":"Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub .","title":"Elm-MicroScheme"},{"location":"about/#directions","text":"To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter.","title":"Directions"},{"location":"about/#layout-of-the-code","text":"---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Eval.elm 40 10 92 src/MicroScheme/Frame.elm 25 0 64 src/MicroScheme/Parser.elm 28 11 56 src/MicroScheme/Interpreter.elm 18 14 43 src/Main.elm 22 0 41 src/MicroScheme/Environment.elm 9 0 19 src/MicroScheme/Expr.elm 4 0 13 src/MicroScheme/Init.elm 3 0 10 ---------------------------------------------------------------------------------- SUM: 149 35 338 ----------------------------------------------------------------------------------","title":"Layout of the code"},{"location":"overview/","text":"Overview Expr Type The Expr type is define in module Expr : type Expr = Z Int | F Float | Str String | Sym String | L (List Expr) | SF SpecialForm type SpecialForm = Define | Lambda | Display | If Parser parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map certain values to symbols, e.g., Str \"+\" to Sym \"+\" . Thus we have > parse symbolTable \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2]) Eval eval : Expr -> Result EvalError Expr Interpreter The interpreter is governed by the three functoions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment , rootFrame : Frame } The root frame maps names to symbols for top level names such as \"+\" and \"*\" as in \"( 1 2 3)\" . At the moment we do not use the environment field. Frames and Environments A frame binds expressions to names: type alias Frame = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#expr-type","text":"The Expr type is define in module Expr : type Expr = Z Int | F Float | Str String | Sym String | L (List Expr) | SF SpecialForm type SpecialForm = Define | Lambda | Display | If","title":"Expr Type"},{"location":"overview/#parser","text":"parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map certain values to symbols, e.g., Str \"+\" to Sym \"+\" . Thus we have > parse symbolTable \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2])","title":"Parser"},{"location":"overview/#eval","text":"eval : Expr -> Result EvalError Expr","title":"Eval"},{"location":"overview/#interpreter","text":"The interpreter is governed by the three functoions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment , rootFrame : Frame } The root frame maps names to symbols for top level names such as \"+\" and \"*\" as in \"( 1 2 3)\" . At the moment we do not use the environment field.","title":"Interpreter"},{"location":"overview/#frames-and-environments","text":"A frame binds expressions to names: type alias Frame = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame","title":"Frames and Environments"}]}