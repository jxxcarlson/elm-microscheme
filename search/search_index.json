{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Elm-MicroScheme Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub . Directions To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter. Layout of the code ---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Parser.elm 40 16 115 src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Function.elm 40 0 103 src/MicroScheme/Eval.elm 33 13 94 src/MicroScheme/Interpreter.elm 37 26 83 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Environment.elm 21 1 53 src/Main.elm 22 0 41 src/MicroScheme/Init.elm 7 0 22 src/repl.js 8 4 19 src/MicroScheme/Expr.elm 2 0 12 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 287 61 727 ----------------------------------------------------------------------------------","title":"Home"},{"location":"#elm-microscheme","text":"Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub .","title":"Elm-MicroScheme"},{"location":"#directions","text":"To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter.","title":"Directions"},{"location":"#layout-of-the-code","text":"---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Parser.elm 40 16 115 src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Function.elm 40 0 103 src/MicroScheme/Eval.elm 33 13 94 src/MicroScheme/Interpreter.elm 37 26 83 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Environment.elm 21 1 53 src/Main.elm 22 0 41 src/MicroScheme/Init.elm 7 0 22 src/repl.js 8 4 19 src/MicroScheme/Expr.elm 2 0 12 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 287 61 727 ----------------------------------------------------------------------------------","title":"Layout of the code"},{"location":"about/","text":"Elm-MicroScheme Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub . Directions To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter. Layout of the code ---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Parser.elm 40 16 115 src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Function.elm 40 0 103 src/MicroScheme/Eval.elm 33 13 94 src/MicroScheme/Interpreter.elm 37 26 83 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Environment.elm 21 1 53 src/Main.elm 22 0 41 src/MicroScheme/Init.elm 7 0 22 src/repl.js 8 4 19 src/MicroScheme/Expr.elm 2 0 12 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 287 61 727 ----------------------------------------------------------------------------------","title":"Elm-MicroScheme"},{"location":"about/#elm-microscheme","text":"Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub .","title":"Elm-MicroScheme"},{"location":"about/#directions","text":"To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter.","title":"Directions"},{"location":"about/#layout-of-the-code","text":"---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Parser.elm 40 16 115 src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Function.elm 40 0 103 src/MicroScheme/Eval.elm 33 13 94 src/MicroScheme/Interpreter.elm 37 26 83 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Environment.elm 21 1 53 src/Main.elm 22 0 41 src/MicroScheme/Init.elm 7 0 22 src/repl.js 8 4 19 src/MicroScheme/Expr.elm 2 0 12 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 287 61 727 ----------------------------------------------------------------------------------","title":"Layout of the code"},{"location":"examples/","text":"Examples Scheme Constructors and destructors > (cons 4 5) (4 . 5) > (cons 1 (quote (2 3))) (1 2 3) > (cons (+ 1 2 3) 5) (6 . 5) > (cons (quote (+ 1 2 3)) 5) ((+ 1 2 3) . 5) > (list 1 2 3) (1 2 3) > (cons 0 (list 1 2 3)) (0 1 2 3) > (car (list 1 2 3)) 1 > (car (quote (1 2 3)) 1 > (cdr (list 1 2 3)) (2 3) > (cdr (quote (1 2 3))) (2 3) Define > (define x 3) x > x 3 > (define (square x) (* x x)) square > (square 4) 16 Higher order > (define (inc x) (+ 1 x)) inc > (map inc (list 1 2 3)) (2 3 4) Lambda > ((Lambda (x) (* x x)) 2) 4 > (map (Lambda (x) (* x x)) (list 1 2 3 4)) (1 4 9 16) Notice that you can look up values in the environment: > (lookup square) [Lambda (L [Str \"x\"]) (L [Sym \"*\",Str \"x\",Str \"x\"])] You can turn debugging on and off: Debug ----- > (+ 1 2) 3 > debug true > (+ 1 2) PARSE: Ok (L [Sym \"+\",Z 1,Z 2]) 3 > debug PARSE: Ok (Sym \"debug\") false > (+ 1 2) 3 Something slightly more complex: > (define (isEven n) (= (remainder n 2) 0)) isEven > (isEven 17) False If > (if (< 0 1) A B) A Function Dictionary functionDict : Dict String (List Expr -> Result EvalError Expr) functionDict = Dict.fromList [ ( \"+\", evalPlus ) , ( \"*\", evalTimes ) , ( \"roundTo\", roundTo ) , ( \"=\", equalNumbers ) , ( \"<\", ltPredicate ) , ( \">\", gtPredicate ) , ( \"<=\", ltePredicate ) , ( \">=\", gtePredicate ) , ( \"remainder\", remainder ) ] Arithmetic (+ 1 2 3 4) => 10 (* 1 2 3 4) => 24 (roundTo 2 3.1416) => 3.14 (= 2 3) => False (< 2 3) => True (<= 2 3) => True (> 2 3) => False (>=2 3) => False (remainder 15 2) => 1","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#scheme","text":"","title":"Scheme"},{"location":"examples/#constructors-and-destructors","text":"> (cons 4 5) (4 . 5) > (cons 1 (quote (2 3))) (1 2 3) > (cons (+ 1 2 3) 5) (6 . 5) > (cons (quote (+ 1 2 3)) 5) ((+ 1 2 3) . 5) > (list 1 2 3) (1 2 3) > (cons 0 (list 1 2 3)) (0 1 2 3) > (car (list 1 2 3)) 1 > (car (quote (1 2 3)) 1 > (cdr (list 1 2 3)) (2 3) > (cdr (quote (1 2 3))) (2 3)","title":"Constructors and destructors"},{"location":"examples/#define","text":"> (define x 3) x > x 3 > (define (square x) (* x x)) square > (square 4) 16","title":"Define"},{"location":"examples/#higher-order","text":"> (define (inc x) (+ 1 x)) inc > (map inc (list 1 2 3)) (2 3 4)","title":"Higher order"},{"location":"examples/#lambda","text":"> ((Lambda (x) (* x x)) 2) 4 > (map (Lambda (x) (* x x)) (list 1 2 3 4)) (1 4 9 16) Notice that you can look up values in the environment: > (lookup square) [Lambda (L [Str \"x\"]) (L [Sym \"*\",Str \"x\",Str \"x\"])] You can turn debugging on and off: Debug ----- > (+ 1 2) 3 > debug true > (+ 1 2) PARSE: Ok (L [Sym \"+\",Z 1,Z 2]) 3 > debug PARSE: Ok (Sym \"debug\") false > (+ 1 2) 3 Something slightly more complex: > (define (isEven n) (= (remainder n 2) 0)) isEven > (isEven 17) False","title":"Lambda"},{"location":"examples/#if","text":"> (if (< 0 1) A B) A","title":"If"},{"location":"examples/#function-dictionary","text":"functionDict : Dict String (List Expr -> Result EvalError Expr) functionDict = Dict.fromList [ ( \"+\", evalPlus ) , ( \"*\", evalTimes ) , ( \"roundTo\", roundTo ) , ( \"=\", equalNumbers ) , ( \"<\", ltPredicate ) , ( \">\", gtPredicate ) , ( \"<=\", ltePredicate ) , ( \">=\", gtePredicate ) , ( \"remainder\", remainder ) ]","title":"Function Dictionary"},{"location":"examples/#arithmetic","text":"(+ 1 2 3 4) => 10 (* 1 2 3 4) => 24 (roundTo 2 3.1416) => 3.14 (= 2 3) => False (< 2 3) => True (<= 2 3) => True (> 2 3) => False (>=2 3) => False (remainder 15 2) => 1","title":"Arithmetic"},{"location":"notes/","text":"Notes Minimal Scheme quote if lambda define set! begin cons car cdr null? A somewhat longer list: lambda - Defines a new anonymous procedure. define - Defines a named procedure or value. if - Conditional expression that evaluates one of two expressions based on a condition. let - Defines a new variable within a local scope. let* - Like let, but allows defining variables that depend on each other. letrec - Like let, but allows defining mutually recursive variables. set! - Assigns a new value to an existing variable. begin - Evaluates a sequence of expressions in order and returns the result of the last expression. quote - Returns a given expression without evaluating it. list - Constructs a list of its arguments. cons - Constructs a new pair. car - Returns the first element of a pair. cdr - Returns the second element of a pair. null? - Returns #t if the argument is the empty list. eq? - Returns #t if two arguments are the same object in memory. equal? - Returns #t if two arguments are structurally equivalent. map - Applies a given procedure to each element of a list and returns a new list of the results. fold (also known as reduce) - Applies a given procedure to a list, starting with an initial value, and accumulates the results. filter - Returns a new list containing only the elements of a given list that satisfy a given predicate. cond - A more flexible version of if that allows evaluating multiple expressions based on different conditions. and - Evaluates a sequence of expressions and returns #f if any of them evaluate to #f. or - Evaluates a sequence of expressions and returns #t if any of them evaluate to #t. not - Returns the logical negation of its argument. apply - Calls a procedure with a list of arguments","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes"},{"location":"notes/#minimal-scheme","text":"quote if lambda define set! begin cons car cdr null? A somewhat longer list: lambda - Defines a new anonymous procedure. define - Defines a named procedure or value. if - Conditional expression that evaluates one of two expressions based on a condition. let - Defines a new variable within a local scope. let* - Like let, but allows defining variables that depend on each other. letrec - Like let, but allows defining mutually recursive variables. set! - Assigns a new value to an existing variable. begin - Evaluates a sequence of expressions in order and returns the result of the last expression. quote - Returns a given expression without evaluating it. list - Constructs a list of its arguments. cons - Constructs a new pair. car - Returns the first element of a pair. cdr - Returns the second element of a pair. null? - Returns #t if the argument is the empty list. eq? - Returns #t if two arguments are the same object in memory. equal? - Returns #t if two arguments are structurally equivalent. map - Applies a given procedure to each element of a list and returns a new list of the results. fold (also known as reduce) - Applies a given procedure to a list, starting with an initial value, and accumulates the results. filter - Returns a new list containing only the elements of a given list that satisfy a given predicate. cond - A more flexible version of if that allows evaluating multiple expressions based on different conditions. and - Evaluates a sequence of expressions and returns #f if any of them evaluate to #f. or - Evaluates a sequence of expressions and returns #t if any of them evaluate to #t. not - Returns the logical negation of its argument. apply - Calls a procedure with a list of arguments","title":"Minimal Scheme"},{"location":"overview/","text":"Overview Expr Type Expressions in MicroScheme are represented by the type Expr : type Expr = Z Int | F Float | B Bool | Str String | Sym String | L (List Expr) | Pair Expr Expr | Lambda Expr Expr | Define Expr Expr | If Expr Expr Expr Parser Here is an example of how to run the parser: $ elm repl > import MicroScheme.Parser exposing(parse) > import MicroScheme.Init exposing(rootFrame) > parse rootFrame \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2]) The module Parser has parse as its single export: parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map string values to symbols, e.g., Str \"+\" to Sym \"+\" as in the example above. Eval The module Eval exports just one function, eval : Environment -> Expr -> Result EvalError Expr eval env expr = evalResult env (Ok expr) It calls evalResult , which is a long exercise in pattern-matching: evalResult : Environment -> Result EvalError Expr -> Result EvalError Expr evalResult env resultExpr = case resultExpr of Err error -> Err error Ok expr -> case expr of Z n -> Ok (Z n) F x -> Ok (F x) Sym s -> Ok (Sym s) Str s -> Ok (Str s) L ((Sym functionName) :: args) -> dispatchFunction env functionName args L ((Lambda (L params) (L body)) :: args) -> evalResult env (applyLambdaToExpressionList params body args) L ((Lambda (L params) body) :: args) -> evalResult env (applyLambdaToExpression params body args) If (L boolExpr_) expr1 expr2 -> evalBoolExpr env boolExpr_ expr1 expr2 L ((Str name) :: rest) -> Err <| EvalError 0 (\"Unknown symbol: \" ++ name) L exprList_ -> Err <| EvalError -1 <| \"!!! \" _ -> Err <| EvalError 0 <| \"Missing case (eval), expr = XXX\" Function evalResult matches the various patterns presented by expr , mapping them to handlers which act on the subexpressions or the pattern, returning a value of type Result EvalError Expr . As an example, the pattern L ((Sym functionName) :: args) is handlde by the function call dispatchFunction env functionName args , which operates by evaluating args using the environment env , then applying the function of type List Expr -> Result EvalError Expr . This function is gotten by looking up the key functionName in a suitable dictionary. One more example. The function applyLambdaToExpressionList creates a temporary frame with bindings for the variable names and arguments of the lambda expression, then uses that frame to resolve the names which appear in the function body. The result of this operation is then evaluated in the current environment by evalResult . applyLambdaToExpressionList : List Expr -> List Expr -> List Expr -> Result EvalError Expr applyLambdaToExpressionList params body args = let -- `A throw-away frame. It will never be used -- outside of this function. frameResult : Result Frame.FrameError Frame.Frame frameResult = Frame.addBindings (Frame.varNames params) args Frame.empty in case frameResult of Err frameError -> Err frameError |> Result.mapError (\\err -> FR err) Ok frame -> Ok (List.map (Frame.resolve frame) body |> L) Ok (List.map (Frame.resolve frame) body |> L) The Function module exports built-in functions for use by eval , e.g., Function.plus and Function.times . To add a new function to MicroScheme, add an implementation of it to module Function and add its name to symbolStrings in module Init . Interpreter The interpreter is governed by the three functions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment } The function init returns a state in which the input and output fields are empty strings and the environment is a tree with one node, the rootFrame . The root frame holds a dictionary that maps strings to symbols, e.g., \"+\" to Sym \"+\" . The function input accepts a strings and sets the field input to it. The function step runs the parse on input , runs eval on the result, and puts a string version of the result in output . Frames and Environments A frame binds expressions to names: type alias Frame = { id : FrameId , bindings : Bindings } type alias FrameId = Int type alias Bindings = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame Numbers Module Numbers exports the type NumberError and the functions coerce and roundTo . coerce : List Expr -> Result NumberError (Either (List Int) (List Float)) If the argument of coerce is a list of Z Int , it returns a Left (List Int) value. If it is a list o F Float , it returns a value of type Right (List Float) . If it is a list of values of types Z Int and F Float , it coerces the values of type Z Int to Z Float and returns a value of type Right (List Float) . In all other cases it return Left NotAllNumbers The function call roundTo 2 x returns the value x rounded to two decicmals. Examples No coercion: > (+ 1 2) 3 > (+ 1.003 2) 3.003 > (+ 1.003 2.7) 3.7030000000000003 In the last case, floating point arithmetic produces an incorrect result. Better looking is the below > (roundTo 2 (+ 1.003 2.7)) 3.7 Coercion: > (+ 1.1 2) 3.1","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#expr-type","text":"Expressions in MicroScheme are represented by the type Expr : type Expr = Z Int | F Float | B Bool | Str String | Sym String | L (List Expr) | Pair Expr Expr | Lambda Expr Expr | Define Expr Expr | If Expr Expr Expr","title":"Expr Type"},{"location":"overview/#parser","text":"Here is an example of how to run the parser: $ elm repl > import MicroScheme.Parser exposing(parse) > import MicroScheme.Init exposing(rootFrame) > parse rootFrame \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2]) The module Parser has parse as its single export: parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map string values to symbols, e.g., Str \"+\" to Sym \"+\" as in the example above.","title":"Parser"},{"location":"overview/#eval","text":"The module Eval exports just one function, eval : Environment -> Expr -> Result EvalError Expr eval env expr = evalResult env (Ok expr) It calls evalResult , which is a long exercise in pattern-matching: evalResult : Environment -> Result EvalError Expr -> Result EvalError Expr evalResult env resultExpr = case resultExpr of Err error -> Err error Ok expr -> case expr of Z n -> Ok (Z n) F x -> Ok (F x) Sym s -> Ok (Sym s) Str s -> Ok (Str s) L ((Sym functionName) :: args) -> dispatchFunction env functionName args L ((Lambda (L params) (L body)) :: args) -> evalResult env (applyLambdaToExpressionList params body args) L ((Lambda (L params) body) :: args) -> evalResult env (applyLambdaToExpression params body args) If (L boolExpr_) expr1 expr2 -> evalBoolExpr env boolExpr_ expr1 expr2 L ((Str name) :: rest) -> Err <| EvalError 0 (\"Unknown symbol: \" ++ name) L exprList_ -> Err <| EvalError -1 <| \"!!! \" _ -> Err <| EvalError 0 <| \"Missing case (eval), expr = XXX\" Function evalResult matches the various patterns presented by expr , mapping them to handlers which act on the subexpressions or the pattern, returning a value of type Result EvalError Expr . As an example, the pattern L ((Sym functionName) :: args) is handlde by the function call dispatchFunction env functionName args , which operates by evaluating args using the environment env , then applying the function of type List Expr -> Result EvalError Expr . This function is gotten by looking up the key functionName in a suitable dictionary. One more example. The function applyLambdaToExpressionList creates a temporary frame with bindings for the variable names and arguments of the lambda expression, then uses that frame to resolve the names which appear in the function body. The result of this operation is then evaluated in the current environment by evalResult . applyLambdaToExpressionList : List Expr -> List Expr -> List Expr -> Result EvalError Expr applyLambdaToExpressionList params body args = let -- `A throw-away frame. It will never be used -- outside of this function. frameResult : Result Frame.FrameError Frame.Frame frameResult = Frame.addBindings (Frame.varNames params) args Frame.empty in case frameResult of Err frameError -> Err frameError |> Result.mapError (\\err -> FR err) Ok frame -> Ok (List.map (Frame.resolve frame) body |> L) Ok (List.map (Frame.resolve frame) body |> L) The Function module exports built-in functions for use by eval , e.g., Function.plus and Function.times . To add a new function to MicroScheme, add an implementation of it to module Function and add its name to symbolStrings in module Init .","title":"Eval"},{"location":"overview/#interpreter","text":"The interpreter is governed by the three functions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment } The function init returns a state in which the input and output fields are empty strings and the environment is a tree with one node, the rootFrame . The root frame holds a dictionary that maps strings to symbols, e.g., \"+\" to Sym \"+\" . The function input accepts a strings and sets the field input to it. The function step runs the parse on input , runs eval on the result, and puts a string version of the result in output .","title":"Interpreter"},{"location":"overview/#frames-and-environments","text":"A frame binds expressions to names: type alias Frame = { id : FrameId , bindings : Bindings } type alias FrameId = Int type alias Bindings = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame","title":"Frames and Environments"},{"location":"overview/#numbers","text":"Module Numbers exports the type NumberError and the functions coerce and roundTo . coerce : List Expr -> Result NumberError (Either (List Int) (List Float)) If the argument of coerce is a list of Z Int , it returns a Left (List Int) value. If it is a list o F Float , it returns a value of type Right (List Float) . If it is a list of values of types Z Int and F Float , it coerces the values of type Z Int to Z Float and returns a value of type Right (List Float) . In all other cases it return Left NotAllNumbers The function call roundTo 2 x returns the value x rounded to two decicmals. Examples No coercion: > (+ 1 2) 3 > (+ 1.003 2) 3.003 > (+ 1.003 2.7) 3.7030000000000003 In the last case, floating point arithmetic produces an incorrect result. Better looking is the below > (roundTo 2 (+ 1.003 2.7)) 3.7 Coercion: > (+ 1.1 2) 3.1","title":"Numbers"}]}