{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Elm-MicroScheme Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub . Directions To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter. Layout of the code ---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Interpreter.elm 33 20 66 src/MicroScheme/Parser.elm 28 11 55 src/MicroScheme/Environment.elm 19 0 48 src/MicroScheme/Eval.elm 20 11 47 src/MicroScheme/Function.elm 17 0 45 src/Main.elm 22 0 41 src/repl.js 8 4 19 src/MicroScheme/Expr.elm 4 0 13 src/MicroScheme/Init.elm 7 0 13 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 235 47 532","title":"Home"},{"location":"about/#elm-microscheme","text":"Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub .","title":"Elm-MicroScheme"},{"location":"about/#directions","text":"To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter.","title":"Directions"},{"location":"about/#layout-of-the-code","text":"---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Interpreter.elm 33 20 66 src/MicroScheme/Parser.elm 28 11 55 src/MicroScheme/Environment.elm 19 0 48 src/MicroScheme/Eval.elm 20 11 47 src/MicroScheme/Function.elm 17 0 45 src/Main.elm 22 0 41 src/repl.js 8 4 19 src/MicroScheme/Expr.elm 4 0 13 src/MicroScheme/Init.elm 7 0 13 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 235 47 532","title":"Layout of the code"},{"location":"notes/","text":"Notes Minimal Scheme quote if lambda define set! begin cons car cdr null? A somewhat longer list: lambda - Defines a new anonymous procedure. define - Defines a named procedure or value. if - Conditional expression that evaluates one of two expressions based on a condition. let - Defines a new variable within a local scope. let* - Like let, but allows defining variables that depend on each other. letrec - Like let, but allows defining mutually recursive variables. set! - Assigns a new value to an existing variable. begin - Evaluates a sequence of expressions in order and returns the result of the last expression. quote - Returns a given expression without evaluating it. list - Constructs a list of its arguments. cons - Constructs a new pair. car - Returns the first element of a pair. cdr - Returns the second element of a pair. null? - Returns #t if the argument is the empty list. eq? - Returns #t if two arguments are the same object in memory. equal? - Returns #t if two arguments are structurally equivalent. map - Applies a given procedure to each element of a list and returns a new list of the results. fold (also known as reduce) - Applies a given procedure to a list, starting with an initial value, and accumulates the results. filter - Returns a new list containing only the elements of a given list that satisfy a given predicate. cond - A more flexible version of if that allows evaluating multiple expressions based on different conditions. and - Evaluates a sequence of expressions and returns #f if any of them evaluate to #f. or - Evaluates a sequence of expressions and returns #t if any of them evaluate to #t. not - Returns the logical negation of its argument. apply - Calls a procedure with a list of arguments","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes"},{"location":"notes/#minimal-scheme","text":"quote if lambda define set! begin cons car cdr null? A somewhat longer list: lambda - Defines a new anonymous procedure. define - Defines a named procedure or value. if - Conditional expression that evaluates one of two expressions based on a condition. let - Defines a new variable within a local scope. let* - Like let, but allows defining variables that depend on each other. letrec - Like let, but allows defining mutually recursive variables. set! - Assigns a new value to an existing variable. begin - Evaluates a sequence of expressions in order and returns the result of the last expression. quote - Returns a given expression without evaluating it. list - Constructs a list of its arguments. cons - Constructs a new pair. car - Returns the first element of a pair. cdr - Returns the second element of a pair. null? - Returns #t if the argument is the empty list. eq? - Returns #t if two arguments are the same object in memory. equal? - Returns #t if two arguments are structurally equivalent. map - Applies a given procedure to each element of a list and returns a new list of the results. fold (also known as reduce) - Applies a given procedure to a list, starting with an initial value, and accumulates the results. filter - Returns a new list containing only the elements of a given list that satisfy a given predicate. cond - A more flexible version of if that allows evaluating multiple expressions based on different conditions. and - Evaluates a sequence of expressions and returns #f if any of them evaluate to #f. or - Evaluates a sequence of expressions and returns #t if any of them evaluate to #t. not - Returns the logical negation of its argument. apply - Calls a procedure with a list of arguments","title":"Minimal Scheme"},{"location":"overview/","text":"Overview Expr Type The Expr type is define in module Expr : type Expr = Z Int | F Float | Str String | Sym String | L (List Expr) | SF SpecialForm type SpecialForm = Define | Lambda | Display | If Parser parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map certain values to symbols, e.g., Str \"+\" to Sym \"+\" . Thus we have > import MicroScheme.Parser exposing(parse) > import MicroScheme.Init exposing(rootFrame) > parse rootFrame \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2]) Eval The module Eval exports just one function, eval : Expr -> Result EvalError Expr It calls evalResult , which is a long exercise in pattern-matching: evalResult : Result EvalError Expr -> Result EvalError Expr evalResult resultExpr = case resultExpr of Err error -> Err error Ok expr -> case expr of Z n -> Ok (Z n) F r -> Ok (F r) Sym s -> Ok (Sym s) L ((Sym name) :: rest) -> case Function.dispatch name of Err _ -> Err (EvalError 3 (\"dispatch \" ++ name ++ \" did not return a value\")) Ok f -> Result.map f (evalArgs rest) |> Result.Extra.join L ((L ((SF Lambda) :: (L params) :: (L body) :: [])) :: args) -> applyLambda params body args |> evalResult _ -> Err <| EvalError 0 \"Missing case (eval)\" In the above code, Function.dispatch takes a function name as input and produces a value of type Result EvalError (List Expr -> Result EvalError Expr) as output. The function evalArgs evaluates the arguments of the function called: evalArgs : List Expr -> Result EvalError (List Expr) evalArgs args = List.map (evalResult << Ok) args |> Result.Extra.combine The function applyLambda creates a temporary frame with bindings for the variable names and arguments of the lambda expression, then uses that frame to resolve the names which appear in the function body. applyLambda : List Expr -> List Expr -> List Expr -> Result EvalError Expr applyLambda params body args = let frameResult : Result Frame.FrameError Frame.Frame frameResult = Frame.addBindings (Frame.varNames params) args Frame.empty in case frameResult of Err frameError -> Err frameError |> Result.mapError (\\err -> FR err) Ok frame -> Ok (List.map (Frame.resolve frame) body |> L) The Function module exports built-in functions for use by eval , e.g., Function.plus and Function.times . To add a new function to MicroScheme, add an implementation of it to module Function and add its name to symbolStrings in module Init . Interpreter The interpreter is governed by the three functions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment } The function init returns a state in which the input and output fields are empty strings and the environment is a tree with one node, the rootFrame . The root frame holds a dictionary that maps strings to symbols, e.g., \"+\" to Sym \"+\" . The function input accepts a strings and sets the field input to it. The function step runs the parse on input , runs eval on the result, and puts a string version of the result in output . Frames and Environments A frame binds expressions to names: type alias Frame = { id : FrameId , bindings : Bindings } type alias FrameId = Int type alias Bindings = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame Numbers Module Numbers exports the type NumberError and the functions coerce and roundTo . coerce : List Expr -> Result NumberError (Either (List Int) (List Float)) If the argument of coerce is a list of Z Int , it returns a Left (List Int) value. If it is a list o F Float , it returns a value of type Right (List Float) . If it is a list of values of types Z Int and F Float , it coerces the values of type Z Int to Z Float and returns a value of type Right (List Float) . In all other cases it return Left NotAllNumbers The function call roundTo 2 x returns the value x rounded to two decicmals. Examples No coercion: > (+ 1 2) 3 > (+ 1.003 2) 3.003 > (+ 1.003 2.7) 3.7030000000000003 In the last case, floating point arithmetic produces an incorrect result. Better looking is the below > (roundTo 2 (+ 1.003 2.7)) 3.7 Coercion: > (+ 1.1 2) 3.1","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#expr-type","text":"The Expr type is define in module Expr : type Expr = Z Int | F Float | Str String | Sym String | L (List Expr) | SF SpecialForm type SpecialForm = Define | Lambda | Display | If","title":"Expr Type"},{"location":"overview/#parser","text":"parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map certain values to symbols, e.g., Str \"+\" to Sym \"+\" . Thus we have > import MicroScheme.Parser exposing(parse) > import MicroScheme.Init exposing(rootFrame) > parse rootFrame \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2])","title":"Parser"},{"location":"overview/#eval","text":"The module Eval exports just one function, eval : Expr -> Result EvalError Expr It calls evalResult , which is a long exercise in pattern-matching: evalResult : Result EvalError Expr -> Result EvalError Expr evalResult resultExpr = case resultExpr of Err error -> Err error Ok expr -> case expr of Z n -> Ok (Z n) F r -> Ok (F r) Sym s -> Ok (Sym s) L ((Sym name) :: rest) -> case Function.dispatch name of Err _ -> Err (EvalError 3 (\"dispatch \" ++ name ++ \" did not return a value\")) Ok f -> Result.map f (evalArgs rest) |> Result.Extra.join L ((L ((SF Lambda) :: (L params) :: (L body) :: [])) :: args) -> applyLambda params body args |> evalResult _ -> Err <| EvalError 0 \"Missing case (eval)\" In the above code, Function.dispatch takes a function name as input and produces a value of type Result EvalError (List Expr -> Result EvalError Expr) as output. The function evalArgs evaluates the arguments of the function called: evalArgs : List Expr -> Result EvalError (List Expr) evalArgs args = List.map (evalResult << Ok) args |> Result.Extra.combine The function applyLambda creates a temporary frame with bindings for the variable names and arguments of the lambda expression, then uses that frame to resolve the names which appear in the function body. applyLambda : List Expr -> List Expr -> List Expr -> Result EvalError Expr applyLambda params body args = let frameResult : Result Frame.FrameError Frame.Frame frameResult = Frame.addBindings (Frame.varNames params) args Frame.empty in case frameResult of Err frameError -> Err frameError |> Result.mapError (\\err -> FR err) Ok frame -> Ok (List.map (Frame.resolve frame) body |> L) The Function module exports built-in functions for use by eval , e.g., Function.plus and Function.times . To add a new function to MicroScheme, add an implementation of it to module Function and add its name to symbolStrings in module Init .","title":"Eval"},{"location":"overview/#interpreter","text":"The interpreter is governed by the three functions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment } The function init returns a state in which the input and output fields are empty strings and the environment is a tree with one node, the rootFrame . The root frame holds a dictionary that maps strings to symbols, e.g., \"+\" to Sym \"+\" . The function input accepts a strings and sets the field input to it. The function step runs the parse on input , runs eval on the result, and puts a string version of the result in output .","title":"Interpreter"},{"location":"overview/#frames-and-environments","text":"A frame binds expressions to names: type alias Frame = { id : FrameId , bindings : Bindings } type alias FrameId = Int type alias Bindings = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame","title":"Frames and Environments"},{"location":"overview/#numbers","text":"Module Numbers exports the type NumberError and the functions coerce and roundTo . coerce : List Expr -> Result NumberError (Either (List Int) (List Float)) If the argument of coerce is a list of Z Int , it returns a Left (List Int) value. If it is a list o F Float , it returns a value of type Right (List Float) . If it is a list of values of types Z Int and F Float , it coerces the values of type Z Int to Z Float and returns a value of type Right (List Float) . In all other cases it return Left NotAllNumbers The function call roundTo 2 x returns the value x rounded to two decicmals. Examples No coercion: > (+ 1 2) 3 > (+ 1.003 2) 3.003 > (+ 1.003 2.7) 3.7030000000000003 In the last case, floating point arithmetic produces an incorrect result. Better looking is the below > (roundTo 2 (+ 1.003 2.7)) 3.7 Coercion: > (+ 1.1 2) 3.1","title":"Numbers"}]}