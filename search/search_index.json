{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"Elm-MicroScheme Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub . Directions To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter. Layout of the code ---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Eval.elm 27 11 76 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Parser.elm 28 11 56 src/MicroScheme/Interpreter.elm 25 20 52 src/MicroScheme/Environment.elm 19 0 48 src/Main.elm 22 0 41 src/MicroScheme/Function.elm 12 0 34 src/MicroScheme/Expr.elm 4 0 13 src/MicroScheme/Init.elm 7 0 13 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 221 43 518 ----------------------------------------------------------------------------------","title":"Home"},{"location":"about/#elm-microscheme","text":"Elm-Microscheme is an implementation of a tiny subset of Scheme written in Elm . Since the aim of the project is educational \u2014 to understand how to build a Scheme interpreter \u2014 I intend to keep the codebase very small even as I work to add new features, e.g., a proper treatment of environments. A good exercise is to fork the project and add whatever features to it that you find interesting or useful. This project is open-source, with the code on GitHub .","title":"Elm-MicroScheme"},{"location":"about/#directions","text":"To compile and run the interpreter, say sh run.sh on the command line. This command will compile the code and start up the command-line interface to the interpreter. Below is a screenshot of a short session with the interpreter.","title":"Directions"},{"location":"about/#layout-of-the-code","text":"---------------------------------------------------------------------------------- File blank comment code ---------------------------------------------------------------------------------- src/MicroScheme/Numbers.elm 45 1 107 src/MicroScheme/Eval.elm 27 11 76 src/MicroScheme/Frame.elm 29 0 73 src/MicroScheme/Parser.elm 28 11 56 src/MicroScheme/Interpreter.elm 25 20 52 src/MicroScheme/Environment.elm 19 0 48 src/Main.elm 22 0 41 src/MicroScheme/Function.elm 12 0 34 src/MicroScheme/Expr.elm 4 0 13 src/MicroScheme/Init.elm 7 0 13 src/MicroScheme/Error.elm 3 0 5 ---------------------------------------------------------------------------------- SUM: 221 43 518 ----------------------------------------------------------------------------------","title":"Layout of the code"},{"location":"notes/","text":"Notes Minimal Scheme quote if lambda define set! begin cons car cdr null? A somewhat longer list: lambda - Defines a new anonymous procedure. define - Defines a named procedure or value. if - Conditional expression that evaluates one of two expressions based on a condition. let - Defines a new variable within a local scope. let* - Like let, but allows defining variables that depend on each other. letrec - Like let, but allows defining mutually recursive variables. set! - Assigns a new value to an existing variable. begin - Evaluates a sequence of expressions in order and returns the result of the last expression. quote - Returns a given expression without evaluating it. list - Constructs a list of its arguments. cons - Constructs a new pair. car - Returns the first element of a pair. cdr - Returns the second element of a pair. null? - Returns #t if the argument is the empty list. eq? - Returns #t if two arguments are the same object in memory. equal? - Returns #t if two arguments are structurally equivalent. map - Applies a given procedure to each element of a list and returns a new list of the results. fold (also known as reduce) - Applies a given procedure to a list, starting with an initial value, and accumulates the results. filter - Returns a new list containing only the elements of a given list that satisfy a given predicate. cond - A more flexible version of if that allows evaluating multiple expressions based on different conditions. and - Evaluates a sequence of expressions and returns #f if any of them evaluate to #f. or - Evaluates a sequence of expressions and returns #t if any of them evaluate to #t. not - Returns the logical negation of its argument. apply - Calls a procedure with a list of arguments","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes"},{"location":"notes/#minimal-scheme","text":"quote if lambda define set! begin cons car cdr null? A somewhat longer list: lambda - Defines a new anonymous procedure. define - Defines a named procedure or value. if - Conditional expression that evaluates one of two expressions based on a condition. let - Defines a new variable within a local scope. let* - Like let, but allows defining variables that depend on each other. letrec - Like let, but allows defining mutually recursive variables. set! - Assigns a new value to an existing variable. begin - Evaluates a sequence of expressions in order and returns the result of the last expression. quote - Returns a given expression without evaluating it. list - Constructs a list of its arguments. cons - Constructs a new pair. car - Returns the first element of a pair. cdr - Returns the second element of a pair. null? - Returns #t if the argument is the empty list. eq? - Returns #t if two arguments are the same object in memory. equal? - Returns #t if two arguments are structurally equivalent. map - Applies a given procedure to each element of a list and returns a new list of the results. fold (also known as reduce) - Applies a given procedure to a list, starting with an initial value, and accumulates the results. filter - Returns a new list containing only the elements of a given list that satisfy a given predicate. cond - A more flexible version of if that allows evaluating multiple expressions based on different conditions. and - Evaluates a sequence of expressions and returns #f if any of them evaluate to #f. or - Evaluates a sequence of expressions and returns #t if any of them evaluate to #t. not - Returns the logical negation of its argument. apply - Calls a procedure with a list of arguments","title":"Minimal Scheme"},{"location":"overview/","text":"Overview Expr Type The Expr type is define in module Expr : type Expr = Z Int | F Float | Str String | Sym String | L (List Expr) | SF SpecialForm type SpecialForm = Define | Lambda | Display | If Parser parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map certain values to symbols, e.g., Str \"+\" to Sym \"+\" . Thus we have > parse symbolTable \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2]) Eval eval : Expr -> Result EvalError Expr Interpreter The interpreter is governed by the three functoions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment , rootFrame : Frame } The root frame maps names to symbols for top level names such as \"+\" and \"*\" as in \"( 1 2 3)\" . At the moment we do not use the environment field. Frames and Environments A frame binds expressions to names: type alias Frame = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#expr-type","text":"The Expr type is define in module Expr : type Expr = Z Int | F Float | Str String | Sym String | L (List Expr) | SF SpecialForm type SpecialForm = Define | Lambda | Display | If","title":"Expr Type"},{"location":"overview/#parser","text":"parse : Frame -> String -> Result (List P.DeadEnd) Expr parse table str = P.run exprParser str |> Result.map (Environment.applyFrame table) The first argument of parse is the root frame, which is used to map certain values to symbols, e.g., Str \"+\" to Sym \"+\" . Thus we have > parse symbolTable \"(+ 1 2)\" Ok (L [Sym \"+\",Z 1,Z 2])","title":"Parser"},{"location":"overview/#eval","text":"eval : Expr -> Result EvalError Expr","title":"Eval"},{"location":"overview/#interpreter","text":"The interpreter is governed by the three functoions init : State input : String -> State -> State step : State -> State where type alias State = { input : String , output : String , environment : Environment , rootFrame : Frame } The root frame maps names to symbols for top level names such as \"+\" and \"*\" as in \"( 1 2 3)\" . At the moment we do not use the environment field.","title":"Interpreter"},{"location":"overview/#frames-and-environments","text":"A frame binds expressions to names: type alias Frame = Dict String Expr An environment is a tree of frames with a distinguished (movable) node, i.e., a zipper: type alias Environment = Zipper Frame","title":"Frames and Environments"}]}